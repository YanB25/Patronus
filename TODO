[-] Add API p->should_exit()
[-] Add key_to_dsm_addr API for addressing.
- Implemente all the APIs in Patronus
- Bench the performance / coroutine.

[-] when QP fails, before recovery, we should wait for all the on-going contexts, and set result to false.
[-] then, we should return all the onging coro ids. so that, the client_master will yield to these coroutines
[-] then, all the worker will realize that they fail. so they all retries.
[-] refactor: the API for client should combine into one.

[-] implement relinquish, and let the server gc the memory window. so that I can bench for a looong time instead of several ms.
- try to optimize the performance of single-thread patronus-basic (takes 2-3 days if lucky). actually: I got sick and sleep for 2-3 days =).
- remember to measu  re the latency of each op, and the penalty of coroutine switching.

- then, try the correctness and performance of multiple threads. should scale according to NR_DIRECTORY, I guess.

[-] evaluate the maxinum bind_mw performance I can get:
    - What if pipeline poll cq? for the bench_mw.cpp, advancely post several batch.
    - What if totally does not poll? just try_poll and does not wait for anything.
    - tune up the post-send-batch for bench_mw_post_send.

[one day]
Possible performance optimization:
- performance of buffer pool? should be REALLY high.
- server can bind_mw in a batch (from one ibv_post_send call). There will be only one signal(, or every signal) and one interaction to NIC.
    - use prepare_handle_request_acquire, and commit_handle_request_acquire internal API. that would be easy to adopt the codes.
- API change: do not expose server coroutine scheduling to the outer world. Furthermore, no copy is required.
- change to multiple threads: 
    - each client thread bind to one mid. 
    - one server thread can handle multiple mid simultaneously. one server thread for one DirectoryConnnection (one-to-one mapping) 
- Adopt the header to 