TODO:
[-] Add API p->should_exit()
[-] Add key_to_dsm_addr API for addressing.
- Implemente all the APIs in Patronus
- Bench the performance / coroutine.

[-] when QP fails, before recovery, we should wait for all the on-going contexts, and set result to false.
[-] then, we should return all the onging coro ids. so that, the client_master will yield to these coroutines
[-] then, all the worker will realize that they fail. so they all retries.
[-] refactor: the API for client should combine into one.

[-] implement relinquish, and let the server gc the memory window. so that I can bench for a looong time instead of several ms.
- try to optimize the performance of single-thread patronus-basic (takes 2-3 days if lucky). actually: I got sick and sleep for 2-3 days =).
- remember to measure the latency of each op, and the penalty of coroutine switching.

- then, try the correctness and performance of multiple threads. should scale according to NR_DIRECTORY, I guess.


- evaluate the maxinum bind_mw performance I can get:
    - What if pipeline poll cq? for the bench_mw.cpp, advancely post several batch.
    - What if totally does not poll? just try_poll and does not wait for anything.
    - tune up the post-send-batch for bench_mw_post_send.

Possible performance optimization:
- server can bind_mw in a batch (from one ibv_post_send call). There will be only one signal.
    - use prepare_handle_request_acquire, and commit_handle_request_acquire internal API. that would be easy to adopt the codes.